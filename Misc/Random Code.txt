//	RECT spriteRect;

	
	/*
	spriteRect.top = 0;
	spriteRect.left = 0;
	spriteRect.right = 150;
	spriteRect.bottom = 150;

	this->boundary = Point(xBoundary - spriteRect.right, yBoundary - spriteRect.bottom);
	*/

	/*
	d3dPosition.x = (float) position.x;
	d3dPosition.y = (float) position.y;
	d3dPositionOffset.x = (float) position.x - 150;
	d3dPositionOffset.y = (float) position.y - 150;
	*/

void Player::draw(LPDIRECT3DDEVICE9 d3dDevice) {
//	if(vertexBuffer != NULL) { vertexBuffer->Release(); }

	/*
	int i;
	PlayerVertex * pVtx;

	D3DXMATRIX matTransform;
	D3DXMatrixTranslation(&matTransform, (float) position.x, (float) position.y, 1);

	if(FAILED(vertexBuffer->Lock(0, sizeof(PlayerVertex) * PLAYER_VERTEX_COUNT, (void **) &pVtx, 0))) { return; }
	memcpy(pVtx, vertex, sizeof(PlayerVertex) * PLAYER_VERTEX_COUNT);
	for(i=0;i<PLAYER_VERTEX_COUNT;i++) { D3DXVec3TransformCoord(&pVtx[i].pos, &vertex[i].pos, &matTransform); }
	vertexBuffer->Unlock();
	
	d3dDevice->SetStreamSource(0, vertexBuffer, 0, sizeof(PlayerVertex) );
	d3dDevice->SetFVF(D3DFVF_PLAYER_VERTEX);
	d3dDevice->SetRenderState(D3DRS_COLORVERTEX, FALSE);
	d3dDevice->DrawPrimitive(D3DPT_TRIANGLEFAN, 0, 3);
	*/
}

bool Player::init(LPDIRECT3DDEVICE9 d3dDevice) {
	/*
	int i;
	VOID * pVtx;

	for(i=0;i<PLAYER_VERTEX_COUNT;i++) {
		vertex[i].pos.z = 0.5;
		vertex[i].rhw = 0.5;
		vertex[i].colour = D3DCOLOR_XRGB(255, 0, 0);
	}

	float sizeX = 10;
	float sizeY = 10;
	
	vertex[0].pos.x = (float) position.x - sizeX; vertex[0].pos.y = (float) position.y - sizeY;
	vertex[1].pos.x = (float) position.x + sizeX; vertex[1].pos.y = (float) position.y - sizeY;
	vertex[2].pos.x = (float) position.x + sizeX; vertex[2].pos.y = (float) position.y + sizeY;
	vertex[3].pos.x = (float) position.x + sizeX; vertex[3].pos.y = (float) position.y + sizeY;
	vertex[4].pos.x = (float) position.x - sizeX; vertex[4].pos.y = (float) position.y + sizeY;
	vertex[5].pos.x = (float) position.x - sizeX; vertex[5].pos.y = (float) position.y - sizeY;
	
	if(FAILED(d3dDevice->CreateVertexBuffer(PLAYER_VERTEX_COUNT * sizeof(PlayerVertex), 0, D3DFVF_PLAYER_VERTEX, D3DPOOL_DEFAULT, &vertexBuffer, NULL))) { return false; }
	
	if(FAILED(vertexBuffer->Lock(0, sizeof(PlayerVertex) * PLAYER_VERTEX_COUNT, (void **) &pVtx, 0 ))) { return false; }
	memcpy(pVtx, vertex, sizeof(PlayerVertex) * PLAYER_VERTEX_COUNT);
	vertexBuffer->Unlock();
	*/

	return true;
}


struct PlayerVertex {
    D3DXVECTOR3 pos;
	float rhw;
    DWORD colour;
};

#define D3DFVF_PLAYER_VERTEX (D3DFVF_XYZRHW|D3DFVF_DIFFUSE)
#define PLAYER_VERTEX_COUNT 5


protected:
	PlayerVertex vertex[PLAYER_VERTEX_COUNT];
	LPDIRECT3DVERTEXBUFFER9 vertexBuffer;


struct ObjectVertex {
    D3DXVECTOR3 pos;
	float rhw;
    DWORD colour;
};

#define D3DFVF_OBJECT_VERTEX (D3DFVF_XYZRHW|D3DFVF_DIFFUSE)

protected:
	ObjectVertex vertex[4];
	LPDIRECT3DVERTEXBUFFER9 vertexBuffer;



	int _x = 8,		_y = 8,		_s = _x * _y;
	int _w = 126,	_h = 126,	_xi = _w + 2,	_yi = _h + 2;
	int _sx = 1,	_sy = 1,	_c = 0;
	SpriteSheetOffset * offsets = new SpriteSheetOffset[_s];
	for(int i=0;i<_x;i++,_sx=1) {
		for(int j=0;j<_y;j++) {
			offsets[_c].x = _sx;
			offsets[_c].y = _sy;
			offsets[_c].w = _w;
			offsets[_c].h = _h;
			_sx += _xi;
			_c++;
		}
		_sy += _yi;
	}
	playerSpriteSheet = new Sprite("Alien.png", settings->getValue("Sprite Directory"), d3dDevice);


	playerSprites = new SpriteSheet(playerSpriteSheet, offsets, _s);

	delete [] offsets;



			/*
			int w = World.GRID_SIZE;
			for(int i=0;i<world.gridSize.x;i++) {
				for(int j=0;j<world.gridSize.y;j++) {
					topLeft =     new Point( i*w,     j*w);
					topRight =    new Point((i*w)+w,  j*w);
					bottomRight = new Point((i*w)+w, (j*w)+w);
					bottomLeft =  new Point( i*w,    (j*w)+w);
					
					if(mode == MODE_TILING && selectedGridBlock != null && i == selectedGridBlock.x && j == selectedGridBlock.y) {
						Graphics2D g2 = (Graphics2D) g;
						Stroke s = g2.getStroke();
						g2.setStroke(new BasicStroke(2));
						g2.setColor(new Color(255, 0, 0));
						
						g2.drawLine(topLeft.x,     topLeft.y,     topRight.x,    topRight.y);
						g2.drawLine(topRight.x,    topRight.y,    bottomRight.x, bottomRight.y);
						g2.drawLine(bottomRight.x, bottomRight.y, bottomLeft.x,  bottomLeft.y);
						g2.drawLine(bottomLeft.x,  bottomLeft.y,  topLeft.x,     topLeft.y);
						
						g2.setStroke(s);
					}
					else {
						g.setColor(new Color(64, 64, 64));
						
						g.drawLine(topLeft.x,     topLeft.y,     topRight.x,    topRight.y);
						g.drawLine(topRight.x,    topRight.y,    bottomRight.x, bottomRight.y);
						g.drawLine(bottomRight.x, bottomRight.y, bottomLeft.x,  bottomLeft.y);
						g.drawLine(bottomLeft.x,  bottomLeft.y,  topLeft.x,     topLeft.y);
					}
				}
			}
			*/



	/*public void drawTile(BufferedImage tileToDraw, int x, int y, Graphics g) {
		if(mode == MODE_TILING) {
			Graphics2D g2 = (Graphics2D) g;
			Point topLeft = new Point( x * World.GRID_SIZE, y * World.GRID_SIZE);
			int xPos = topLeft.x - World.GRID_SIZE;
			int yPos = topLeft.y;
			g2.drawImage(tileToDraw, null, xPos, yPos);
		}
	}*/





/*
	public static Vector<SpriteSheet> parseFrom(File file, boolean append) {
		if(file == null || !file.exists() || !file.isFile()) { return null; }
		
		// parse until empty line or attributes
		
		// cycle through variables parsed
		
		// then read x number of attributes
		
		Variables variables;
		Variables attributes;
		Variable v;
		BufferedReader in;
		String input;
		String data;
		int spriteIndex;
		String spriteName, spriteType;
		try {
			variables = new Variables();
			
			in = new BufferedReader(new FileReader(file));
			while((input = in.readLine()) != null) {
				data = input.trim();
				
				if(data.length() == 0) {
					continue;
				}
				else {
					v = Variable.parseFrom(input);
					
					if(v != null) {
						variables.add(v);
					}
					
					if(v.getID().equalsIgnoreCase("Attributes")) {
						this.name = variables.getValue("Sprite Name");
						String spriteSheetFileName;
						int spriteSheetType;
						Point firstSpriteOffset;
						Dimension spriteSize 
						
						int numberOfAttributes;
						try { numberOfAttributes = Integer.parseInt(v.getValue()); }
						catch(NumberFormatException e) { return false; }
						
						attributes = new Variables();
						for(int i=0;i<numberOfAttributes;i++) {
							for(int j=0;j<3;j++) {
								attributes.add(Variable.parseFrom(in.readLine()));
							}
							try { spriteIndex = Integer.parseInt(attributes.getValue("Sprite")); }
							catch(NumberFormatException e) { return false; }
							if(spriteIndex < 0 || spriteIndex >= sprites.size()) { return false; }
							spriteName = attributes.getValue("Name");
							spriteType = attributes.getValue("Type");
							if(spriteName == null || spriteType == null) { return false; }
							sprites.elementAt(spriteIndex).setName(spriteName);
							sprites.elementAt(spriteIndex).setParentName(this.name);
							sprites.elementAt(spriteIndex).setType(Sprite.parseType(spriteType));
						}
						
						variables = new Variables();
					}
				}
			}
			
			in.close();
		}
		catch(IOException e) {
			return false;
		}
		
		return true;
	}*/




//	public Vector<String> textureNames;
	

//		this.textureNames = new Vector<String>();

		
		/*
		// read in the texture names
		input = in.readLine();
		String texturesHeader = input.substring(0, input.indexOf(':', 0)).trim();
		if(!texturesHeader.equals("Textures")) {
			System.out.println("ERROR: Corrupted world file. Expected header \"Textures\", found \"" + texturesHeader + "\".");
			return null;
		}
		int numberOfTextures = Integer.valueOf(input.substring(input.lastIndexOf(':', input.length() - 1) + 1, input.length()).trim());
		for(int i=0;i<numberOfTextures;i++) {
			input = in.readLine().trim();
			if(input != null && input.length() != 0) {
				if(!world.textureNames.contains(input)) {
					world.textureNames.add(input);
				}
			}
		}
		*/


		
		/*
		// write the textures
		out.println("Textures: " + this.textureNames.size());
		for(int i=0;i<this.textureNames.size();i++) {
			out.println("\t" + this.textureNames.elementAt(i));
		}
		*/




		/*Entity e;
		Sprite s;
		int index;*/
		

			/*
			e = world.getTile(i);
			index = e.spriteSheetIndex;
			if(index < 0) { editorWindow.spriteSheets.getSpriteSheetIndex(e.getSprite().getParentName()); }
			if(index >= 0) {
				s = editorWindow.spriteSheets.getSpriteSheet(index).getSprite(e.getSpriteIndex());
				if(s != null) {
					s.paintOn(g, e.location.x * World.GRID_SIZE, e.location.y * World.GRID_SIZE);
				}
			}*/


			/*
			e = world.getObject(i);
			index = e.spriteSheetIndex;
			if(index < 0) { editorWindow.spriteSheets.getSpriteSheetIndex(e.getSprite().getParentName()); }
			if(index >= 0) {
				s = editorWindow.spriteSheets.getSpriteSheet(index).getSprite(e.getSpriteIndex());
				if(s != null) {
					s.paintOn(g, e.location.x, e.location.y);
				}
			}*/


//			world.getPlayer().getSprite().paintOn(g, world.getPlayer().location.x, world.getPlayer().location.y);




//			world.getPlayer().getSprite().paintOn(g, world.getPlayer().location.x, world.getPlayer().location.y);





ofstream out("test.txt");
	SpriteSheets * spriteSheets = SpriteSheets::parseFrom(settings->getValue("SpriteSheet File"), settings->getValue("Sprite Directory"), d3dDevice);
	out << "SIZE: " << spriteSheets->size() << endl << endl;
	for(int i=0;i<spriteSheets->size();i++) {
		out << i << ": " << spriteSheets->elementAt(i)->size();
		if(spriteSheets->elementAt(i)->getName() == NULL) {
			out << " - NULL" << endl;
		}
		else {
			out << " - " << spriteSheets->elementAt(i)->getName() << endl;
		}
		for(int j=0;j<spriteSheets->elementAt(i)->size();j++) {
			out << j;
			if(spriteSheets->elementAt(i)->elementAt(j)->getName() == NULL) {
				out << ": NULL" << endl;
			}
			else {
				out << ": \"" << spriteSheets->elementAt(i)->elementAt(j)->getName() << "\"" << endl;
			}
		}
		out << endl;
		out << endl;
	}
	out.close();


	
	
	public SpriteSheet(BufferedImage image,
					   int xOffset,
					   int yOffset,
					   int width,
					   int height,
					   int xIncrement,
					   int yIncrement,
					   int numberOfSprites) {
		this.name = null;
		sprites = new Vector<Sprite>((numberOfSprites <= 1) ? 10 : numberOfSprites);
		
		if(image == null) {
			System.out.println("ERROR: SpriteSheet cannot be parsed from null image.");
			System.exit(1);
		}
		
		for(int i=0;i<numberOfSprites;i++) {
			sprites.add(new Sprite(image.getSubimage(xOffset + (xIncrement * i),
													 yOffset + (yIncrement * i),
													 width,
													 height), i));
		}
	}

	public SpriteSheet(Sprite image, String name, int xOffset, int yOffset, int width, int height, int xIncrement, int yIncrement, int numberOfSprites) {
		this(image.getImage(), xOffset, yOffset, width, height, xIncrement, yIncrement, numberOfSprites);
	}


	SpriteSheet(Sprite * externalSpriteSheet,
				int xOffset,
				int yOffset,
				int width,
				int height,
				int xIncrement,
				int yIncrement,
				int numberOfSprites);


SpriteSheet::SpriteSheet(Sprite * externalSpriteSheet,
						 int xOffset,
						 int yOffset,
						 int width,
						 int height,
						 int xIncrement,
						 int yIncrement,
						 int numberOfSprites)
							: name(NULL),
							  spriteSheet(externalSpriteSheet) {
	for(int i=0;i<numberOfSprites;i++) {
		sprites.push_back(new Sprite(xOffset + (xIncrement * i),
									 yOffset + (yIncrement * i),
									 width,
									 height,
									 spriteSheet->getTexture(),
									 spriteSheet->getSprite()));
	}
}






		/*
		USES_CONVERSION;
		wstring spriteFileName;
		if(directory != NULL) {
			spriteFileName.append(wstring(A2W(directory)));
			if(_stricmp(W2A(spriteFileName.substr(spriteFileName.length() - 1, spriteFileName.length()).c_str()), ("\\")) != 0 &&
			   _stricmp(W2A(spriteFileName.substr(spriteFileName.length() - 1, spriteFileName.length()).c_str()), ("/")) != 0) {
				spriteFileName.append(L"\\");
			}
		}
		spriteFileName.append(A2W(fileName));
		*/

//		if(FAILED(D3DXCreateTextureFromFile(d3dDevice, spriteFileName.c_str(), &texture))) {
//			quit("Error", "Error loading sprite texture \"%s\".", W2A(spriteFileName.c_str()));
//		}


//	USES_CONVERSION;
//	D3DXCreateFont(d3dDevice, size, 0, weight, 0, italic, DEFAULT_CHARSET, OUT_DEFAULT_PRECIS, DEFAULT_QUALITY, DEFAULT_PITCH | FF_DONTCARE, A2W(face), &d3dFont);



//	USES_CONVERSION;
//	font->getD3DFont()->DrawText(sprite, A2W(buffer), length, &textBox, alignment, colour);


	/*if(keyboardState[DIK_ESCAPE] & 0x80) {
		if(!escapeKeyPressed) {
			if(helpScreenActive) {
				helpScreenActive = false;
			}
			else if(!mainMenuActive) {
				mainMenuActive = true;
			}
			else {
				PostQuitMessage(0);
			}
		}
		escapeKeyPressed = true;
	}
	else {
		escapeKeyPressed = false;
	}

	processMainMenuInput();*/




/*void Game::processMainMenuInput() {
	if(helpScreenActive || !mainMenuActive) { return; }

	if(keyboardState[DIK_RETURN] & 0x80 || keyboardState[DIK_SPACE] & 0x80) {
		if(!menuSelectKeyPressed) {
			switch(mainMenu->getIndex()) {
				// start game in single player mode
				case 0:
					mainMenuActive = false;
					break;
				// start game in 2 player mode
				case 1:
					mainMenuActive = false;
					break;
				// display help screen
				case 2:
					helpScreenActive = true;
					break;
				// quit the game
				case 3:
					PostQuitMessage(0);
					break;
			}
		}
		menuSelectKeyPressed = true;
	}
	else { menuSelectKeyPressed = false; }

	// move menu selection up
	if(keyboardState[DIK_UP] & 0x80 || keyboardState[DIK_W] & 0x80) {
		if(!menuUpKeyPressed) {
			mainMenu->moveUp();
		}
		menuUpKeyPressed = true;
	}
	else { menuUpKeyPressed = false; }

	// move menu selection down
	if(keyboardState[DIK_DOWN] & 0x80 || keyboardState[DIK_S] & 0x80) {
		if(!menuDownKeyPressed) {
			mainMenu->moveDown();
		}
		menuDownKeyPressed = true;
	}
	else { menuDownKeyPressed = false; }
}*/





/*
bool CollisionHandler::checkRadiusIntersection(Edge & e, D3DXVECTOR2 & p, double r) {
	Vertex a = e.a;
	Vertex b = e.b;
	double dx = b.x - a.x;
	double dy = b.y - a.y;
	double dr = sqrt((dx * dx) + (dy * dy));
	double d = (a.x * b.y) - (b.x * a.y);
	double xi1 = ((d * dy) + (((dy < 0) ? -1 : 1) * dx * sqrt(((r * r) * (dr * dr)) - (d * d)))) / (dr * dr);
	double xi2 = ((d * dy) - (((dy < 0) ? -1 : 1) * dx * sqrt(((r * r) * (dr * dr)) - (d * d)))) / (dr * dr);
	double yi1 = (-((d * dx) + (abs(dy) * sqrt(((r * r) * (dr * dr)) - (d * d))))) / (dr * dr);
	double yi2 = (-((d * dx) - (abs(dy) * sqrt(((r * r) * (dr * dr)) - (d * d))))) / (dr * dr);
	double delta = ((r * r) * (dr * dr)) - (d * d);
	return delta >= 0;
}
*/


#pragma once

#if _DEBUG
#include "Includes.h"
#endif

#include "Vertex.h"

class Edge {
public:
	/*Edge() { a = new Vertex(); b = new Vertex(); }
	Edge(const Vertex & v1, const Vertex & v2) : a(new Vertex(v1)), b(new Vertex(v2)) { }
	Edge(const Edge & e) : a(new Vertex(*e.a)), b(new Vertex(*e.b)) { }
	Edge & operator = (const Edge & e) { delete a; delete b; a = new Vertex(*e.a); b = new Vertex(*e.b); return *this; }
	~Edge() { }*/

	Edge() { }
	Edge(const Vertex & v1, const Vertex & v2) : a(v1), b(v2) { }
	Edge(const Edge & e) : a(e.a), b(e.b) { }
	Edge & operator = (const Edge & e) { a = e.a; b = e.b; return *this; }
	~Edge() { }

	/*
	bool containsVertex(const Vertex & v) { return *a == v || *b == v; }
	double getDeltaX() { return b->x - a->x; }
	double getDeltaY() { return b->y - a->y; }
	double getLength() { return sqrt(pow((double) (b->x - a->x), 2) + pow((double) (b->y - a->y), 2)); }
	*/

	bool containsVertex(const Vertex & v) { return a == v || b == v; }
	double getDeltaX() { return b.x - a.x; }
	double getDeltaY() { return b.y - a.y; }
	double getLength() { return sqrt(pow((double) (b.x - a.x), 2) + pow((double) (b.y - a.y), 2)); }

	static Edge parseFrom(const char * data) {
		char * temp = strtrimcpy(data);
		if(temp == NULL) {
			return Edge();
		}
		char * center = strchr(temp, ';');
		if(center == NULL) {
			delete [] temp;
			return Edge();
		}
		*center = '\0';
		Vertex v1 = Vertex::parseFrom(temp);
		Vertex v2 = Vertex::parseFrom(center + sizeof(char));
		delete [] temp;
		return Edge(v1, v2);
	}

	inline bool operator == (const Edge & e) { return (a == e.a) && (b == e.b); }
	inline bool operator != (const Edge & e) { return *this != e; }

#if _DEBUG
	void draw(LPDIRECT3DDEVICE9 d3dDevice) {
		/*
		testDrawLine(d3dDevice, (float) a->x, (float) a->y, (float) b->x, (float) b->y);
		testDrawPoint(d3dDevice, (float) a->x, (float) a->y);
		testDrawPoint(d3dDevice, (float) b->x, (float) b->y);
		*/
		testDrawLine(d3dDevice, (float) a.x, (float) a.y, (float) b.x, (float) b.y);
		testDrawPoint(d3dDevice, (float) a.x, (float) a.y);
		testDrawPoint(d3dDevice, (float) b.x, (float) b.y);
	}
#endif

public:
	Vertex a;
	Vertex b;
};





#pragma once

#include "Includes.h"
#include "Vertex.h"
#include "Edge.h"

class Graph {
public:
	Graph() { }

	~Graph() {
		/*for(unsigned int i=0;i<vertices.size();i++) {
			delete vertices.at(i);
		}*/
		for(unsigned int i=0;i<edges.size();i++) {
			delete edges.at(i);
		}
	}

	/*void addVertex(const Vertex & v) {
		if(!containsVertex(v)) {
			vertices.push_back(new Vertex(v));
		}
	}*/

	void addEdge(const Edge & e) {
		if(!containsEdge(e)) {
			edges.push_back(new Edge(e));
		}
	}

	/*
	void addEdge(const Edge & e) {
		if(!containsEdge(e)) {
			Edge * newEdge = new Edge(e);
			edges.push_back(newEdge);
			if(newEdge->a != NULL) {
				int indexA = indexOfVertex(*e.a);
				if(indexA >= 0) {
					delete newEdge->a;
					newEdge->a = vertices.at(indexA);
				}
				else {
					vertices.push_back(e.a);
				}
			}
			if(newEdge->b != NULL) {
				int indexB = indexOfVertex(*e.b);
				if(indexB >= 0) {
					delete newEdge->b;
					newEdge->b = vertices.at(indexB);
				}
				else {
					vertices.push_back(e.b);
				}
			}
		}
	}*/

	int size() {
		return edges.size();
	}

	/*bool containsVertex(const Vertex & v) {
		for(unsigned int i=0;i<vertices.size();i++) {
			if(*vertices.at(i) == v) {
				return true;
			}
		}
		return false;
	}*/

	bool containsEdge(const Edge & e) {
		for(unsigned int i=0;i<edges.size();i++) {
			if(*edges.at(i) == e) {
				return true;
			}
		}
		return false;
	}

	/*int indexOfVertex(const Vertex & v) {
		for(unsigned int i=0;i<vertices.size();i++) {
			if(*vertices.at(i) == v) {
				return i;
			}
		}
		return -1;
	}*/

	int indexOfEdge(const Edge & e) {
		for(unsigned int i=0;i<edges.size();i++) {
			if(*edges.at(i) == e) {
				return i;
			}
		}
		return -1;
	}

	Edge * elementAt(int i) {
		if(i < 0 || i >= (int) edges.size()) { return NULL; }
		return edges.at(i);
	}

	Edge * getEdge(int i) {
		return elementAt(i);
	}

private:
//	vector<Vertex *> vertices;
	vector<Edge *> edges;
};





