//	RECT spriteRect;

	
	/*
	spriteRect.top = 0;
	spriteRect.left = 0;
	spriteRect.right = 150;
	spriteRect.bottom = 150;

	this->boundary = Point(xBoundary - spriteRect.right, yBoundary - spriteRect.bottom);
	*/

	/*
	d3dPosition.x = (float) position.x;
	d3dPosition.y = (float) position.y;
	d3dPositionOffset.x = (float) position.x - 150;
	d3dPositionOffset.y = (float) position.y - 150;
	*/

void Player::draw(LPDIRECT3DDEVICE9 d3dDevice) {
//	if(vertexBuffer != NULL) { vertexBuffer->Release(); }

	/*
	int i;
	PlayerVertex * pVtx;

	D3DXMATRIX matTransform;
	D3DXMatrixTranslation(&matTransform, (float) position.x, (float) position.y, 1);

	if(FAILED(vertexBuffer->Lock(0, sizeof(PlayerVertex) * PLAYER_VERTEX_COUNT, (void **) &pVtx, 0))) { return; }
	memcpy(pVtx, vertex, sizeof(PlayerVertex) * PLAYER_VERTEX_COUNT);
	for(i=0;i<PLAYER_VERTEX_COUNT;i++) { D3DXVec3TransformCoord(&pVtx[i].pos, &vertex[i].pos, &matTransform); }
	vertexBuffer->Unlock();
	
	d3dDevice->SetStreamSource(0, vertexBuffer, 0, sizeof(PlayerVertex) );
	d3dDevice->SetFVF(D3DFVF_PLAYER_VERTEX);
	d3dDevice->SetRenderState(D3DRS_COLORVERTEX, FALSE);
	d3dDevice->DrawPrimitive(D3DPT_TRIANGLEFAN, 0, 3);
	*/
}

bool Player::init(LPDIRECT3DDEVICE9 d3dDevice) {
	/*
	int i;
	VOID * pVtx;

	for(i=0;i<PLAYER_VERTEX_COUNT;i++) {
		vertex[i].pos.z = 0.5;
		vertex[i].rhw = 0.5;
		vertex[i].colour = D3DCOLOR_XRGB(255, 0, 0);
	}

	float sizeX = 10;
	float sizeY = 10;
	
	vertex[0].pos.x = (float) position.x - sizeX; vertex[0].pos.y = (float) position.y - sizeY;
	vertex[1].pos.x = (float) position.x + sizeX; vertex[1].pos.y = (float) position.y - sizeY;
	vertex[2].pos.x = (float) position.x + sizeX; vertex[2].pos.y = (float) position.y + sizeY;
	vertex[3].pos.x = (float) position.x + sizeX; vertex[3].pos.y = (float) position.y + sizeY;
	vertex[4].pos.x = (float) position.x - sizeX; vertex[4].pos.y = (float) position.y + sizeY;
	vertex[5].pos.x = (float) position.x - sizeX; vertex[5].pos.y = (float) position.y - sizeY;
	
	if(FAILED(d3dDevice->CreateVertexBuffer(PLAYER_VERTEX_COUNT * sizeof(PlayerVertex), 0, D3DFVF_PLAYER_VERTEX, D3DPOOL_DEFAULT, &vertexBuffer, NULL))) { return false; }
	
	if(FAILED(vertexBuffer->Lock(0, sizeof(PlayerVertex) * PLAYER_VERTEX_COUNT, (void **) &pVtx, 0 ))) { return false; }
	memcpy(pVtx, vertex, sizeof(PlayerVertex) * PLAYER_VERTEX_COUNT);
	vertexBuffer->Unlock();
	*/

	return true;
}


struct PlayerVertex {
    D3DXVECTOR3 pos;
	float rhw;
    DWORD colour;
};

#define D3DFVF_PLAYER_VERTEX (D3DFVF_XYZRHW|D3DFVF_DIFFUSE)
#define PLAYER_VERTEX_COUNT 5


protected:
	PlayerVertex vertex[PLAYER_VERTEX_COUNT];
	LPDIRECT3DVERTEXBUFFER9 vertexBuffer;


struct ObjectVertex {
    D3DXVECTOR3 pos;
	float rhw;
    DWORD colour;
};

#define D3DFVF_OBJECT_VERTEX (D3DFVF_XYZRHW|D3DFVF_DIFFUSE)

protected:
	ObjectVertex vertex[4];
	LPDIRECT3DVERTEXBUFFER9 vertexBuffer;



	int _x = 8,		_y = 8,		_s = _x * _y;
	int _w = 126,	_h = 126,	_xi = _w + 2,	_yi = _h + 2;
	int _sx = 1,	_sy = 1,	_c = 0;
	SpriteSheetOffset * offsets = new SpriteSheetOffset[_s];
	for(int i=0;i<_x;i++,_sx=1) {
		for(int j=0;j<_y;j++) {
			offsets[_c].x = _sx;
			offsets[_c].y = _sy;
			offsets[_c].w = _w;
			offsets[_c].h = _h;
			_sx += _xi;
			_c++;
		}
		_sy += _yi;
	}
	playerSpriteSheet = new Sprite("Alien.png", settings->getValue("Sprite Directory"), d3dDevice);


	playerSprites = new SpriteSheet(playerSpriteSheet, offsets, _s);

	delete [] offsets;



			/*
			int w = World.GRID_SIZE;
			for(int i=0;i<world.gridSize.x;i++) {
				for(int j=0;j<world.gridSize.y;j++) {
					topLeft =     new Point( i*w,     j*w);
					topRight =    new Point((i*w)+w,  j*w);
					bottomRight = new Point((i*w)+w, (j*w)+w);
					bottomLeft =  new Point( i*w,    (j*w)+w);
					
					if(mode == MODE_TILING && selectedGridBlock != null && i == selectedGridBlock.x && j == selectedGridBlock.y) {
						Graphics2D g2 = (Graphics2D) g;
						Stroke s = g2.getStroke();
						g2.setStroke(new BasicStroke(2));
						g2.setColor(new Color(255, 0, 0));
						
						g2.drawLine(topLeft.x,     topLeft.y,     topRight.x,    topRight.y);
						g2.drawLine(topRight.x,    topRight.y,    bottomRight.x, bottomRight.y);
						g2.drawLine(bottomRight.x, bottomRight.y, bottomLeft.x,  bottomLeft.y);
						g2.drawLine(bottomLeft.x,  bottomLeft.y,  topLeft.x,     topLeft.y);
						
						g2.setStroke(s);
					}
					else {
						g.setColor(new Color(64, 64, 64));
						
						g.drawLine(topLeft.x,     topLeft.y,     topRight.x,    topRight.y);
						g.drawLine(topRight.x,    topRight.y,    bottomRight.x, bottomRight.y);
						g.drawLine(bottomRight.x, bottomRight.y, bottomLeft.x,  bottomLeft.y);
						g.drawLine(bottomLeft.x,  bottomLeft.y,  topLeft.x,     topLeft.y);
					}
				}
			}
			*/



	/*public void drawTile(BufferedImage tileToDraw, int x, int y, Graphics g) {
		if(mode == MODE_TILING) {
			Graphics2D g2 = (Graphics2D) g;
			Point topLeft = new Point( x * World.GRID_SIZE, y * World.GRID_SIZE);
			int xPos = topLeft.x - World.GRID_SIZE;
			int yPos = topLeft.y;
			g2.drawImage(tileToDraw, null, xPos, yPos);
		}
	}*/





/*
	public static Vector<SpriteSheet> parseFrom(File file, boolean append) {
		if(file == null || !file.exists() || !file.isFile()) { return null; }
		
		// parse until empty line or attributes
		
		// cycle through variables parsed
		
		// then read x number of attributes
		
		Variables variables;
		Variables attributes;
		Variable v;
		BufferedReader in;
		String input;
		String data;
		int spriteIndex;
		String spriteName, spriteType;
		try {
			variables = new Variables();
			
			in = new BufferedReader(new FileReader(file));
			while((input = in.readLine()) != null) {
				data = input.trim();
				
				if(data.length() == 0) {
					continue;
				}
				else {
					v = Variable.parseFrom(input);
					
					if(v != null) {
						variables.add(v);
					}
					
					if(v.getID().equalsIgnoreCase("Attributes")) {
						this.name = variables.getValue("Sprite Name");
						String spriteSheetFileName;
						int spriteSheetType;
						Point firstSpriteOffset;
						Dimension spriteSize 
						
						int numberOfAttributes;
						try { numberOfAttributes = Integer.parseInt(v.getValue()); }
						catch(NumberFormatException e) { return false; }
						
						attributes = new Variables();
						for(int i=0;i<numberOfAttributes;i++) {
							for(int j=0;j<3;j++) {
								attributes.add(Variable.parseFrom(in.readLine()));
							}
							try { spriteIndex = Integer.parseInt(attributes.getValue("Sprite")); }
							catch(NumberFormatException e) { return false; }
							if(spriteIndex < 0 || spriteIndex >= sprites.size()) { return false; }
							spriteName = attributes.getValue("Name");
							spriteType = attributes.getValue("Type");
							if(spriteName == null || spriteType == null) { return false; }
							sprites.elementAt(spriteIndex).setName(spriteName);
							sprites.elementAt(spriteIndex).setParentName(this.name);
							sprites.elementAt(spriteIndex).setType(Sprite.parseType(spriteType));
						}
						
						variables = new Variables();
					}
				}
			}
			
			in.close();
		}
		catch(IOException e) {
			return false;
		}
		
		return true;
	}*/




//	public Vector<String> textureNames;
	

//		this.textureNames = new Vector<String>();

		
		/*
		// read in the texture names
		input = in.readLine();
		String texturesHeader = input.substring(0, input.indexOf(':', 0)).trim();
		if(!texturesHeader.equals("Textures")) {
			System.out.println("ERROR: Corrupted world file. Expected header \"Textures\", found \"" + texturesHeader + "\".");
			return null;
		}
		int numberOfTextures = Integer.valueOf(input.substring(input.lastIndexOf(':', input.length() - 1) + 1, input.length()).trim());
		for(int i=0;i<numberOfTextures;i++) {
			input = in.readLine().trim();
			if(input != null && input.length() != 0) {
				if(!world.textureNames.contains(input)) {
					world.textureNames.add(input);
				}
			}
		}
		*/


		
		/*
		// write the textures
		out.println("Textures: " + this.textureNames.size());
		for(int i=0;i<this.textureNames.size();i++) {
			out.println("\t" + this.textureNames.elementAt(i));
		}
		*/




		/*Entity e;
		Sprite s;
		int index;*/
		

			/*
			e = world.getTile(i);
			index = e.spriteSheetIndex;
			if(index < 0) { editorWindow.spriteSheets.getSpriteSheetIndex(e.getSprite().getParentName()); }
			if(index >= 0) {
				s = editorWindow.spriteSheets.getSpriteSheet(index).getSprite(e.getSpriteIndex());
				if(s != null) {
					s.paintOn(g, e.location.x * World.GRID_SIZE, e.location.y * World.GRID_SIZE);
				}
			}*/


			/*
			e = world.getObject(i);
			index = e.spriteSheetIndex;
			if(index < 0) { editorWindow.spriteSheets.getSpriteSheetIndex(e.getSprite().getParentName()); }
			if(index >= 0) {
				s = editorWindow.spriteSheets.getSpriteSheet(index).getSprite(e.getSpriteIndex());
				if(s != null) {
					s.paintOn(g, e.location.x, e.location.y);
				}
			}*/


//			world.getPlayer().getSprite().paintOn(g, world.getPlayer().location.x, world.getPlayer().location.y);




//			world.getPlayer().getSprite().paintOn(g, world.getPlayer().location.x, world.getPlayer().location.y);





ofstream out("test.txt");
	SpriteSheets * spriteSheets = SpriteSheets::parseFrom(settings->getValue("SpriteSheet File"), settings->getValue("Sprite Directory"), d3dDevice);
	out << "SIZE: " << spriteSheets->size() << endl << endl;
	for(int i=0;i<spriteSheets->size();i++) {
		out << i << ": " << spriteSheets->elementAt(i)->size();
		if(spriteSheets->elementAt(i)->getName() == NULL) {
			out << " - NULL" << endl;
		}
		else {
			out << " - " << spriteSheets->elementAt(i)->getName() << endl;
		}
		for(int j=0;j<spriteSheets->elementAt(i)->size();j++) {
			out << j;
			if(spriteSheets->elementAt(i)->elementAt(j)->getName() == NULL) {
				out << ": NULL" << endl;
			}
			else {
				out << ": \"" << spriteSheets->elementAt(i)->elementAt(j)->getName() << "\"" << endl;
			}
		}
		out << endl;
		out << endl;
	}
	out.close();

